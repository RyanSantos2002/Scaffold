const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');

// --- Helper: Read Config ---
const configPath = path.resolve(__dirname, 'capture', '@Config', 'index.js');
if (!fs.existsSync(configPath)) {
    console.error("Config not found at " + configPath);
    process.exit(1);
}
const config = require(configPath);

// --- Constants ---
const FRONT_PATH = 'C:/Fontes/FrontM8/src'; // Hardcoded based on exploration, could be dynamic
// The JSON file generated by extract-tabs.js
const jsonPath = path.resolve(__dirname, '..', 'output', 'json', config.tela, `${config.tela}.json`);

if (!fs.existsSync(jsonPath)) {
    console.error(`JSON file not found at ${jsonPath}. Run /gerar-json first.`);
    process.exit(1);
}

const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));

// --- Helper: Find Module Path ---
function findModulePath(moduleName) {
    // Try standard naming first: @ModuleName
    let attempt1 = path.join(FRONT_PATH, `@${moduleName}`);
    if (fs.existsSync(attempt1)) return attempt1;

    // Try without @: ModuleName
    let attempt2 = path.join(FRONT_PATH, moduleName);
    if (fs.existsSync(attempt2)) return attempt2;

    // Try verifying case insensitive
    const dirs = fs.readdirSync(FRONT_PATH);
    const found = dirs.find(d => d.replace('@', '').toLowerCase() === moduleName.toLowerCase());
    
    if (found) return path.join(FRONT_PATH, found);

    return null;
}

const modulePath = findModulePath(config.modulo);
if (!modulePath) {
    console.error(`Module folder not found for ${config.modulo} in ${FRONT_PATH}`);
    process.exit(1);
}

console.log(`Target Module: ${modulePath}`);

// --- Main Execution ---
async function run() {
    console.log("Starting Audit & Fix...");

    for (let i = 0; i < jsonData.tabs.length; i++) {
        const tab = jsonData.tabs[i];
        console.log(`\nProcessing Tab [${i}]: ${tab.name} (Grid: ${tab.hasGrid}, Form: ${tab.hasForm})`);

        // 1. Locate HTML
        // output/html/{Modulo}/{MenuPai}/form/Something.html
        // We need to find which HTML corresponds to this tab.
        // The capture script saves per tab??
        // Wait, current capture script saves ONE file per "screen" usually, or multiple if navigation happened.
        // Let's assume the HTMLs are in output/html/{Modulo}/{MenuPai}/form/*.html
        
        // Actually, extract-tabs logic was parsing ONE html file to find tabs.
        // So we use THAT same HTML file as source of truth for ALL tabs in that screen?
        // Or if the tabs are separate HTMLs...
        // Based on `extract-tabs.js`, it finds *A* html file. "files.find(f => f.endsWith('.html'))"
        // So it seems it uses one main HTML.
        const inputDir = path.resolve(__dirname, '..', 'output', 'html', config.modulo, config.menuPai, 'form');
        const files = fs.readdirSync(inputDir);
        const htmlFile = files.find(f => f.endsWith('.html'));

        if (!htmlFile) {
            console.error("HTML Source not found!");
            continue;
        }
        
        const htmlPath = path.join(inputDir, htmlFile);
        const html = fs.readFileSync(htmlPath, 'utf8');
        const $ = cheerio.load(html);

        // 2. Extract Fields for this Tab
        // This is tricky if all tabs are in one HTML.
        // We need to narrow down to the specific tab content if possible.
        // If not, we might process all fields found in the form.
        
        // Strategy: 
        // If i=0 (List), we look for Grid columns.
        // If i>0 (Form), we look for Inputs.
        
        // Narrowing context?
        let context = $;
        // Try to find tab-pane
        // This relies on ID matching or index.
        const tabLinks = $('.nav-tabs li a');
        if (tabLinks.length > i) {
             const href = $(tabLinks[i]).attr('href');
             if (href && href.startsWith('#')) {
                 const id = href.substring(1);
                 const pane = $(`#${id}`);
                 if (pane.length > 0) {
                     // Wrap in cheerio to make it "root"
                     context = cheerio.load(pane.html()); 
                 }
             }
        }
        
    // --- Target Directory Logic ---
    // User convention: src/@Modulo/pages/{firstTabNameLower}/...
    const firstTab = jsonData.tabs[0];
    // Normalize: "Conta" -> "conta", "Entrada Caixa" -> "entradacaixa" (check if kebab-case is needed, but "conta" is simple)
    // Based on find_by_name results: "grupo-tarefa", "modalidade-negocio". So it uses kebab-case!
    
    function toKebabCase(str) {
        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                  .replace(/([a-z])([A-Z])/g, "$1-$2")
                  .replace(/[\s_]+/g, '-')
                  .toLowerCase();
    }
    
    const rootSlug = toKebabCase(firstTab.name);
    const pageDir = path.join(modulePath, 'pages', rootSlug);
    
    console.log(`Target Page Directory: ${pageDir}`);

    if (tab.hasGrid && i === 0) {
        // Main List Grid
        const gridFile = path.join(pageDir, 'list', 'index.tsx');
        if (fs.existsSync(gridFile)) {
             await auditFile(gridFile, context, $, 'grid');
        } else {
             console.log(`     [WARN] Grid file not found at ${gridFile}`);
        }
    } else if (tab.hasGrid) {
        // Tab Grid? Usually inside the tab component or a separate Grid component in the tab folder.
        // Pattern: pages/conta/form/tabs/anexos/index.tsx (which might be the grid itself or contain it)
        const tabSlug = toKebabCase(tab.name);
        // Sometimes "Anexos" -> "anexos". "Follow Up" -> "follow-up".
        const tabFile = path.join(pageDir, 'form', 'tabs', tabSlug, 'index.tsx');
        if (fs.existsSync(tabFile)) {
             await auditFile(tabFile, context, $, 'grid');
        }
    }

    if (tab.hasForm) {
        let formFile;
        if (i === 0) {
             // Main Form?
             // pages/conta/form/index.tsx ? OR pages/conta/form/tabs/conta/index.tsx ?
             // The "Conta" tab is usually the "Principal" one.
             // Looking at find_by_name: pages/conta/form/tabs/conta/index.tsx exists.
             // And pages/conta/form/tabs/index.tsx exists.
             // Let's try likely paths.
             const tabSlug = toKebabCase(tab.name);
             const attempt1 = path.join(pageDir, 'form', 'tabs', tabSlug, 'index.tsx');
             if (fs.existsSync(attempt1)) formFile = attempt1;
             else {
                 const attempt2 = path.join(pageDir, 'form', 'index.tsx');
                 if (fs.existsSync(attempt2)) formFile = attempt2;
                 else {
                     // Check tabs/index.tsx (common for main tab)
                     const attempt3 = path.join(pageDir, 'form', 'tabs', 'index.tsx');
                     if (fs.existsSync(attempt3)) formFile = attempt3;
                 }
             }
        } else {
             const tabSlug = toKebabCase(tab.name);
             const attempt1 = path.join(pageDir, 'form', 'tabs', tabSlug, 'index.tsx');
             if (fs.existsSync(attempt1)) formFile = attempt1;
             else if (i === 0) {
                 // Try tabs/index.tsx for first tab if exact match fails
                 const attempt2 = path.join(pageDir, 'form', 'tabs', 'index.tsx');
                 if (fs.existsSync(attempt2)) formFile = attempt2;
             }
        }

        if (formFile) {
             await auditFile(formFile, context, $, 'form', tab.modelName);
        } else {
             console.log(`     [WARN] Form file not found for tab '${tab.name}'`);
        }
    }
}
}

async function auditFile(filePath, $, original$, type, modelName = null) {
    let content = fs.readFileSync(filePath, 'utf8');
    let modified = false;
    let fieldsFoundInHtml = new Map();

    if (type === 'grid') {
        const columns = new Set();
        original$('script').each((i, el) => {
            const txt = original$(el).html();
            if(!txt) return;
            const matches = txt.matchAll(/field\s*:\s*["']([^"']+)["']/g);
            for(const m of matches) columns.add(m[1]);
        });
        
        // Audit Grid Columns
        for(const col of columns) {
            if (['id', 'Id', 'ID'].includes(col)) continue;
            if (!content.includes(`field="${col}"`) && !content.includes(`field: "${col}"`)) {
                 console.log(`     [MISSING GRID COL] ${col}`);
                 // Inject logic
                 const lastColRegex = /(<Column\s+[^>]*\/>)/g;
                 let match, lastIndex = -1;
                 while ((match = lastColRegex.exec(content)) !== null) lastIndex = match.index + match[0].length;
                 
                 if (lastIndex !== -1) {
                      const newCol = `\n                      <Column field="${col}" title="${formatLabel(col)}" />`;
                      content = content.slice(0, lastIndex) + newCol + content.slice(lastIndex);
                      modified = true;
                 }
            }
        }

    } else if (type === 'form') {
        // HTML Fields
        $('input, select, textarea').each((i, el) => {
             const name = $(el).attr('name') || $(el).attr('id');
             if (!name) return;
             // Skip hidden
             if ($(el).attr('type') === 'hidden') return;
             
             let label = "";
             const id = $(el).attr('id');
             if (id) {
                 const l = original$(`label[for="${id}"]`);
                 if (l.length) label = l.text().trim();
             }
             if(!label) label = formatLabel(name);
             
             fieldsFoundInHtml.set(name, { label, type: $(el).prop('tagName').toLowerCase() });
        });

        for (const [name, info] of fieldsFoundInHtml) {
             if (['id', 'Id', 'ID'].includes(name)) continue;
             const exists = content.includes(`name="${name}"`) || content.includes(`name={'${name}'}`);
             
             if (!exists) {
                 console.log(`     [MISSING FORM FIELD] ${name}`);
                 // Inject
                 const lastFieldRegex = /(<Field\s+[^>]*\/>)/g;
                 let match, lastIndex = -1;
                 while ((match = lastFieldRegex.exec(content)) !== null) lastIndex = match.index + match[0].length;
                 
                 if (lastIndex !== -1) {
                     const newField = `
              <Col span={6}>
                <Field
                  label="${info.label}"
                  name="${name}"
                />
              </Col>`;
                     content = content.slice(0, lastIndex) + newField + content.slice(lastIndex);
                     modified = true;
                 }
             }
        }
        
        if (modified && modelName) {
            await auditModel(modelName, fieldsFoundInHtml);
        }
    }

    if (modified) {
        fs.writeFileSync(filePath, content);
        console.log(`     [FIXED] Updated ${path.basename(filePath)}`);
    }
}



async function auditModel(modelName, fields) {
    // Model search strategy:
    // 1. In component dir?
    // 2. In /c-sharp-to-object logic output?
    // Scaffolding usually creates models in the component folder OR a shared models folder.
    // Based on user conversations, looks like they might be local or in a Models folder.
    // Let's Search for {ModelName}.ts inside the module.
    
    const searchRecursive = (dir) => {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        for (const entry of entries) {
            const res = path.resolve(dir, entry.name);
            if (entry.isDirectory()) {
                const found = searchRecursive(res);
                if (found) return found;
            } else {
                if (entry.name === `${modelName}.ts`) return res;
            }
        }
        return null;
    }
    
    const modelFile = searchRecursive(modulePath);
    if (modelFile) {
        let content = fs.readFileSync(modelFile, 'utf8');
        let modified = false;
        
        for (const [name, info] of fields) {
             if (['id', 'Id', 'ID'].includes(name)) continue;
             
             // Check property
             const regex = new RegExp(`public\\s+${name}\\s*:`, 'i');
             if (!regex.test(content)) {
                  console.log(`     [MISSING MODEL PROP] ${name} in ${path.basename(modelFile)}`);
                  
                  // Inject
                  // Find end of class
                  const lastBrace = content.lastIndexOf('}');
                  if (lastBrace !== -1) {
                      const newProp = `  public ${name}: string = "";\n`;
                      content = content.slice(0, lastBrace) + newProp + content.slice(lastBrace);
                      modified = true;
                  }
             }
        }
        
        if (modified) {
            fs.writeFileSync(modelFile, content);
             console.log("     [FIXED] Updated Model file.");
        }
    } else {
         console.log(`     Model file ${modelName}.ts not found.`);
    }
}


// --- Helper: Format Label ---
function formatLabel(name) {
    // camelCase to Words
    const result = name.replace(/([A-Z])/g, " $1");
    const final = result.charAt(0).toUpperCase() + result.slice(1);
    return final.trim();
}

run();
